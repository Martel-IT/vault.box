{ config, lib, pkgs, ... }:

with lib;
let
  cfg = config.vaultbox.services.vault;
in
{
  config = mkIf cfg.enable {
    
    services.vault = {
      enable = true;
      package = pkgs.vault-bin;

      # 1. LISTENER ADDRESS
      address = "0.0.0.0:${toString cfg.port}";

      # 2. STORAGE BACKEND
      storageBackend = "raft";      
      storagePath = cfg.storagePath;
      storageConfig = ''
        node_id = "${config.networking.hostName}"
      '';

      # 3. TLS CONFIG (Listener)
      tlsCertFile = if cfg.tls.enable then cfg.tls.certFile else null;
      tlsKeyFile  = if cfg.tls.enable then cfg.tls.keyFile else null;

      # 4. EXTRA CONFIG
      # NOTE: We do NOT set api_addr or cluster_addr here.
      # Those are injected via the EnvironmentFile generated by vault-setup
      # to ensure they match the Tailscale DNS name dynamically.
      extraConfig = ''
        ui = true
        disable_mlock = true

        ${cfg.extraConfig}
      '';
    };

    environment.systemPackages = with pkgs; [ vault-bin ];

    # --- VAULT SETUP SERVICE ---
    # Runs before Vault to:
    # 1. Detect Tailscale DNS name
    # 2. Generate/Request Certs
    # 3. Create an env file to configure Vault's API Address dynamically
    systemd.services.vault-setup = {
      description = "Vault Setup: Certs & Tailscale Domain Auto-detection";
      requiredBy = [ "vault.service" ];
      before = [ "vault.service" ];
      wants = [ "tailscaled.service" "network-online.target" ];
      after = [ "tailscaled.service" "network-online.target" ];
      
      path = with pkgs; [ tailscale jq coreutils openssl iputils gnugrep ];
      
      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;

        Restart = "on-failure";
        RestartSec = "5s";
      };

      script = ''
        # Variables
        DATA_DIR="/var/lib/vault-storage"
        CERT_DIR="$DATA_DIR/certs"
        ENV_FILE="$DATA_DIR/vault.env"
        KEY_FILE="$CERT_DIR/vault.key"
        CERT_FILE="$CERT_DIR/vault.crt"

        echo "--- [Vault Setup] Starting ---"
        mkdir -p "$CERT_DIR"
        chown -R vault:vault "$DATA_DIR"
        chmod 700 "$DATA_DIR"

        # A. WAIT FOR TAILSCALE & DNS (Max 60s)
        echo "Waiting for Tailscale and DNS connectivity..."
        TIMEOUT=60
        TS_DOMAIN=""
        
        while [ $TIMEOUT -gt 0 ]; do
          # 1. Check Tailscale Status
          STATUS=$(tailscale status --json 2>/dev/null)
          STATE=$(echo "$STATUS" | jq -r .BackendState)
          
          if [ "$STATE" == "Running" ]; then
             # 2. Check Real Connectivity (DNS)
             if getent hosts google.com >/dev/null 2>&1 || ping -c1 8.8.8.8 >/dev/null 2>&1; then
                TS_DOMAIN=$(echo "$STATUS" | jq -r .Self.DNSName | sed 's/\.$//')
                echo "Tailscale is UP and Network/DNS is working."
                break
             else
                echo "Tailscale is UP but Network/DNS check failed. Retrying..."
             fi
          else
             echo "Waiting for Tailscale (Current State: $STATE)..."
          fi
          
          sleep 2
          let TIMEOUT-=2
        done

        if [ -z "$TS_DOMAIN" ]; then
          echo "WARNING: Tailscale not running or offline after timeout. Fallback to localhost."
          TS_DOMAIN="localhost"
        fi

        echo "Detected Domain: $TS_DOMAIN"

        # B. GENERATE ENV FILE
        echo "VAULT_API_ADDR=https://$TS_DOMAIN:8200" > "$ENV_FILE"
        echo "VAULT_CLUSTER_ADDR=https://$TS_DOMAIN:8201" >> "$ENV_FILE"
        echo "VAULT_UI=true" >> "$ENV_FILE" 

        # C. CERTIFICATE MANAGEMENT
        if [[ "$TS_DOMAIN" == *".ts.net" ]]; then
            echo "Requesting Tailscale Certs for $TS_DOMAIN..."
            
            # loop for certs
            CERT_SUCCESS=false
            for i in {1..5}; do
              if tailscale cert --cert-file "$CERT_FILE" --key-file "$KEY_FILE" "$TS_DOMAIN"; then
                 echo "Certificate obtained successfully!"
                 CERT_SUCCESS=true
                 break
              else
                 echo "ERROR: Requesting certificates (tentativo $i/5). Waiting..."
                 sleep 5
              fi
            done
            
            if [ "$CERT_SUCCESS" = false ]; then
               echo "CRITICAL: Not able to fetch certs from tailscale. Quitting..."
               exit 1
            fi
        else
            # Fallback: Self-Signed
            if [ ! -f "$KEY_FILE" ]; then
              echo "Generating Self-Signed Certs..."
              openssl req -new -newkey rsa:4096 -days 3650 -nodes -x509 \
                -subj "/CN=$TS_DOMAIN" -keyout "$KEY_FILE" -out "$CERT_FILE"
            fi
        fi

        # Fix final permissions
        chown vault:vault "$KEY_FILE" "$CERT_FILE" "$ENV_FILE"
        chmod 600 "$KEY_FILE" "$ENV_FILE"
        chmod 644 "$CERT_FILE"
        
        echo "--- [Vault Setup] Complete. API Addr set to: https://$TS_DOMAIN:8200 ---"
      '';
    };

    environment.interactiveShellInit = ''
      if [ -f ${cfg.dataDir}/vault.env ]; then
         # Reads VAULT_API_ADDR from .env file and exports as VAULT_ADDR
         api_addr=$(grep VAULT_API_ADDR ${cfg.dataDir}/vault.env | cut -d= -f2)
         
         if [ -n "$api_addr" ]; then
           export VAULT_ADDR="$api_addr"
         fi
      fi
    '';

    systemd.services.vault = {
      serviceConfig.EnvironmentFile = "/var/lib/vault-storage/vault.env";
      preStart = lib.mkForce ""; 
    };

    systemd.tmpfiles.rules = [ 
      "d ${cfg.storagePath} 0700 vault vault - -"
      "d /var/lib/vault-storage/certs 0700 vault vault - -"
    ];

    networking.firewall.allowedTCPPorts = [ cfg.port cfg.clusterPort ];
  };
}