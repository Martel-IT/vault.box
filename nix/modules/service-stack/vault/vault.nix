{ config, lib, pkgs, ... }:

with lib;
let
  cfg = config.vaultbox.services.vault;
in
{
  config = mkIf cfg.enable {
    
    services.vault = {
      enable = true;
      package = pkgs.vault-bin;

      # 1. LISTENER ADDRESS
      address = "0.0.0.0:${toString cfg.port}";

      # 2. STORAGE BACKEND
      storageBackend = "raft";      
      storagePath = cfg.storagePath;
      storageConfig = ''
        node_id = "${config.networking.hostName}"
      '';

      # 3. TLS CONFIG (Listener)
      tlsCertFile = if cfg.tls.enable then cfg.tls.certFile else null;
      tlsKeyFile  = if cfg.tls.enable then cfg.tls.keyFile else null;

      # 4. EXTRA CONFIG
      # NOTE: We do NOT set api_addr or cluster_addr here.
      # Those are injected via the EnvironmentFile generated by vault-setup
      # to ensure they match the Tailscale DNS name dynamically.
      extraConfig = ''
        ui = true
        disable_mlock = true

        ${cfg.extraConfig}
      '';
    };

    environment.systemPackages = [ pkgs.vault-bin ];

    # --- VAULT SETUP SERVICE ---
    # Runs before Vault to:
    # 1. Detect Tailscale DNS name
    # 2. Generate/Request Certs
    # 3. Create an env file to configure Vault's API Address dynamically
    systemd.services.vault-setup = {
      description = "Vault Setup: Certs & Tailscale Domain Auto-detection";
      requiredBy = [ "vault.service" ];
      before = [ "vault.service" ];
      wants = [ "tailscaled.service" "network-online.target" ];
      after = [ "tailscaled.service" "network-online.target" ];
      
      path = with pkgs; [ tailscale jq coreutils openssl ];
      
      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;
      };

      script = ''
        # Variables
        DATA_DIR="/var/lib/vault-storage"
        CERT_DIR="$DATA_DIR/certs"
        ENV_FILE="$DATA_DIR/vault.env"
        KEY_FILE="$CERT_DIR/vault.key"
        CERT_FILE="$CERT_DIR/vault.crt"

        echo "--- [Vault Setup] Starting ---"
        mkdir -p "$CERT_DIR"
        chown -R vault:vault "$DATA_DIR"
        chmod 700 "$DATA_DIR"

        # A. WAIT FOR TAILSCALE (Max 30s)
        echo "Waiting for Tailscale..."
        TIMEOUT=30
        TS_DOMAIN=""
        while [ $TIMEOUT -gt 0 ]; do
          STATUS=$(tailscale status --json 2>/dev/null)
          STATE=$(echo "$STATUS" | jq -r .BackendState)
          if [ "$STATE" == "Running" ]; then
            # Extract clean DNS name (remove trailing dot)
            TS_DOMAIN=$(echo "$STATUS" | jq -r .Self.DNSName | sed 's/\.$//')
            break
          fi
          sleep 2
          let TIMEOUT-=2
        done

        if [ -z "$TS_DOMAIN" ]; then
          echo "WARNING: Tailscale not running or offline. Fallback to localhost."
          TS_DOMAIN="localhost"
        fi

        echo "Detected Domain: $TS_DOMAIN"

        # B. GENERATE ENV FILE (For dynamic api_addr)
        # Vault will read these env vars to configure itself
        echo "VAULT_API_ADDR=https://$TS_DOMAIN:8200" > "$ENV_FILE"
        echo "VAULT_CLUSTER_ADDR=https://$TS_DOMAIN:8201" >> "$ENV_FILE"
        # Optional: Force UI to be active
        echo "VAULT_UI=true" >> "$ENV_FILE" 

        # C. CERTIFICATE MANAGEMENT
        # If on Tailscale, request valid certs. Otherwise, self-sign.
        if [[ "$TS_DOMAIN" == *".ts.net" ]]; then
            echo "Requesting Tailscale Certs..."
            tailscale cert --cert-file "$CERT_FILE" --key-file "$KEY_FILE" "$TS_DOMAIN"
        else
            # Fallback: Self-Signed if not on Tailscale
            if [ ! -f "$KEY_FILE" ]; then
              echo "Generating Self-Signed Certs..."
              openssl req -new -newkey rsa:4096 -days 3650 -nodes -x509 \
                -subj "/CN=$TS_DOMAIN" -keyout "$KEY_FILE" -out "$CERT_FILE"
            fi
        fi

        # Fix final permissions
        chown vault:vault "$KEY_FILE" "$CERT_FILE" "$ENV_FILE"
        chmod 600 "$KEY_FILE" "$ENV_FILE"
        chmod 644 "$CERT_FILE"
        
        echo "--- [Vault Setup] Complete. API Addr set to: https://$TS_DOMAIN:8200 ---"
      '';
    };

    # -----------------------------------------------------------
    # 2. VAULT SERVICE OVERRIDE
    # -----------------------------------------------------------
    systemd.services.vault = {
      # Load the dynamic environment variables generated by vault-setup
      serviceConfig.EnvironmentFile = "/var/lib/vault-storage/vault.env";
      
      # Clear the default preStart if any, relying on vault-setup instead
      preStart = lib.mkForce ""; 
    };

    systemd.tmpfiles.rules = [ 
      "d ${cfg.storagePath} 0700 vault vault - -"
      "d /var/lib/vault-storage/certs 0700 vault vault - -"
    ];

    # Firewall
    networking.firewall.allowedTCPPorts = [ cfg.port cfg.clusterPort ];
  };
}